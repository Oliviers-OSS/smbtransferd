// -*- C++ -*-
//
// $Id$

// ****  Code generated by the The ACE ORB (TAO) IDL Compiler ****
// TAO and the TAO IDL Compiler have been developed by:
//       Center for Distributed Object Computing
//       Washington University
//       St. Louis, MO
//       USA
//       http://www.cs.wustl.edu/~schmidt/doc-center.html
// and
//       Distributed Object Computing Laboratory
//       University of California at Irvine
//       Irvine, CA
//       USA
//       http://doc.ece.uci.edu/
// and
//       Institute for Software Integrated Systems
//       Vanderbilt University
//       Nashville, TN
//       USA
//       http://www.isis.vanderbilt.edu/
//
// Information about TAO is available at:
//     http://www.cs.wustl.edu/~schmidt/TAO.html


// TAO_IDL - Generated from 
// be/be_codegen.cpp:577

#ifndef _TAO_IDL_REMOTESERVERSSETS_CPP_
#define _TAO_IDL_REMOTESERVERSSETS_CPP_


#include "remoteServersSetS.h"
#include "tao/PortableServer/Operation_Table_Perfect_Hash.h"
#include "tao/PortableServer/Upcall_Command.h"
#include "tao/PortableServer/Upcall_Wrapper.h"
#include "tao/PortableServer/Basic_SArguments.h"
#include "tao/PortableServer/Object_SArgument_T.h"
#include "tao/PortableServer/Special_Basic_SArguments.h"
#include "tao/PortableServer/UB_String_SArguments.h"
#include "tao/PortableServer/Var_Size_SArgument_T.h"
#include "tao/PortableServer/TypeCode_SArg_Traits.h"
#include "tao/PortableServer/Object_SArg_Traits.h"
#include "tao/PortableServer/get_arg.h"
#include "tao/Special_Basic_Arguments.h"
#include "tao/UB_String_Arguments.h"
#include "tao/TAO_Server_Request.h"
#include "tao/ORB_Core.h"
#include "tao/Profile.h"
#include "tao/Stub.h"
#include "tao/IFR_Client_Adapter.h"
#include "tao/Object_T.h"
#include "tao/AnyTypeCode/TypeCode.h"
#include "tao/AnyTypeCode/DynamicC.h"
#include "tao/CDR.h"
#include "tao/operation_details.h"
#include "tao/PortableInterceptor.h"
#include "tao/Basic_Arguments.h"
#include "tao/Object_Argument_T.h"
#include "tao/Special_Basic_Arguments.h"
#include "tao/UB_String_Arguments.h"
#include "tao/Var_Size_Argument_T.h"
#include "ace/Dynamic_Service.h"
#include "ace/Malloc_Allocator.h"

#if !defined (__ACE_INLINE__)
#include "remoteServersSetS.inl"
#endif /* !defined INLINE */

// TAO_IDL - Generated from
// be/be_visitor_arg_traits.cpp:71
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Arg traits specializations.
namespace TAO
{
  
  // TAO_IDL - Generated from
  // be/be_visitor_arg_traits.cpp:903

#if !defined (_REMOTESERVERSSET_EVENT__SARG_TRAITS_)
#define _REMOTESERVERSSET_EVENT__SARG_TRAITS_
  
  template<>
  class SArg_Traits<RemoteServersSet::Event>
    : public
        Var_Size_SArg_Traits_T<
            RemoteServersSet::Event,
            RemoteServersSet::Event_var,
            RemoteServersSet::Event_out,
            TAO::Any_Insert_Policy_Stream <RemoteServersSet::Event>
          >
  {
  };

#endif /* end #if !defined */
  
  // TAO_IDL - Generated from
  // be/be_visitor_arg_traits.cpp:123

#if !defined (_REMOTESERVERSSET_EVENTLISTENER__SARG_TRAITS_)
#define _REMOTESERVERSSET_EVENTLISTENER__SARG_TRAITS_
  
  template<>
  class  SArg_Traits<RemoteServersSet::EventListener>
    : public
        Object_SArg_Traits_T<
            RemoteServersSet::EventListener_ptr,
            RemoteServersSet::EventListener_var,
            RemoteServersSet::EventListener_out,
            TAO::Any_Insert_Policy_Stream <RemoteServersSet::EventListener_ptr>
          >
  {
  };

#endif /* end #if !defined */
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_arg_traits.cpp:71
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Arg traits specializations.
namespace TAO
{
  
  // TAO_IDL - Generated from
  // be/be_visitor_arg_traits.cpp:903

#if !defined (_REMOTESERVERSSET_EVENT__ARG_TRAITS_)
#define _REMOTESERVERSSET_EVENT__ARG_TRAITS_
  
  template<>
  class Arg_Traits<RemoteServersSet::Event>
    : public
        Var_Size_Arg_Traits_T<
            RemoteServersSet::Event,
            RemoteServersSet::Event_var,
            RemoteServersSet::Event_out,
            TAO::Any_Insert_Policy_Stream <RemoteServersSet::Event>
          >
  {
  };

#endif /* end #if !defined */
  
  // TAO_IDL - Generated from
  // be/be_visitor_arg_traits.cpp:123

#if !defined (_REMOTESERVERSSET_EVENTLISTENER__ARG_TRAITS_)
#define _REMOTESERVERSSET_EVENTLISTENER__ARG_TRAITS_
  
  template<>
  class  Arg_Traits<RemoteServersSet::EventListener>
    : public
        Object_Arg_Traits_T<
            RemoteServersSet::EventListener_ptr,
            RemoteServersSet::EventListener_var,
            RemoteServersSet::EventListener_out,
            TAO::Objref_Traits<RemoteServersSet::EventListener>,
            TAO::Any_Insert_Policy_Stream <RemoteServersSet::EventListener_ptr>
          >
  {
  };

#endif /* end #if !defined */
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_interface.cpp:1511

class TAO_RemoteServersSet_Management_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_RemoteServersSet_Management_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_RemoteServersSet_Management_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     38, 38, 38, 38, 38, 38, 38, 38, 38, 38,
     38, 38, 38, 38, 38, 38, 38, 38, 38, 38,
     38, 38, 38, 38, 38, 38, 38, 38, 38, 38,
     38, 38, 38, 38, 38, 38, 38, 38, 38, 38,
     38, 38, 38, 38, 38, 38, 38, 38, 38, 38,
     38, 38, 38, 38, 38, 38, 38, 38, 38, 38,
     38, 38, 38, 38, 38, 38, 38, 38, 38, 38,
     38, 38, 38, 38, 38, 38, 38, 38, 38, 38,
     38, 38, 38, 38, 38, 38, 38, 38, 38, 38,
     38, 38, 38, 38, 38, 38, 38, 38, 38, 38,
     38, 38, 38, 38, 38, 38, 38, 38, 38,  0,
     38, 38, 38, 38, 38, 38, 38, 38, 38, 38,
     38, 38, 38, 38, 38, 38, 38, 38, 38,  0,
     38, 38,  0,  5, 38, 38, 38, 38, 38, 38,
     38, 38, 38, 38, 38, 38, 38, 38, 38, 38,
     38, 38, 38,  0, 38, 38, 38, 38, 38, 38,
     38, 38, 15,  0, 38, 38, 38, 38, 38, 38,
     38, 38, 38, 38, 38, 38, 38, 38, 38, 38,
     38, 38, 38, 38, 38, 38, 38, 38, 38, 38,
     38, 38, 38, 38, 38, 38, 38, 38, 38, 38,
     38, 38, 38, 38, 38, 38, 38, 38, 38, 38,
     38, 38, 38, 38, 38, 38, 38, 38, 38, 38,
     38, 38, 38, 38, 38, 38, 38, 38, 38, 38,
     38, 38, 38, 38, 38, 38, 38, 38, 38, 38,
     38, 38, 38, 38, 38, 38, 38, 38, 38, 38,
     38, 38, 38, 38, 38, 38,
#else
     38, 38, 38, 38, 38, 38, 38, 38, 38, 38,
     38, 38, 38, 38, 38, 38, 38, 38, 38, 38,
     38, 38, 38, 38, 38, 38, 38, 38, 38, 38,
     38, 38, 38, 38, 38, 38, 38, 38, 38, 38,
     38, 38, 38, 38, 38, 38, 38, 38, 38, 38,
     38, 38, 38, 38, 38, 38, 38, 38, 38, 38,
     38, 38, 38, 38, 38, 38, 38, 38, 38, 38,
     38, 38, 38, 38, 38, 38, 38, 38, 38, 38,
     38, 38, 38, 38, 38, 38, 38, 38, 38, 38,
     38, 38, 38, 38, 38,  0, 38,  0, 38, 38,
      0,  5, 38, 38, 38, 38, 38, 38, 38, 38,
     38, 38, 38, 38,  0, 15,  0, 38, 38, 38,
     38, 38, 38, 38, 38, 38, 38, 38,
#endif /* ACE_MVS */
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const TAO_operation_db_entry *
TAO_RemoteServersSet_Management_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 11,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 22,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 37,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 3,
      WORDLIST_SIZE = 16
    };

  static const TAO_operation_db_entry  wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"_is_a", &POA_RemoteServersSet::Management::_is_a_skel, 0},
      {"_component", &POA_RemoteServersSet::Management::_component_skel, 0},
      {"_non_existent", &POA_RemoteServersSet::Management::_non_existent_skel, 0},
      {"_repository_id", &POA_RemoteServersSet::Management::_repository_id_skel, 0},
      {"_interface", &POA_RemoteServersSet::Management::_interface_skel, 0},
      {"_get_currentServer", &POA_RemoteServersSet::Management::_get_currentServer_skel, 0},
      {"_set_currentServer", &POA_RemoteServersSet::Management::_set_currentServer_skel, 0},
      {"start", &POA_RemoteServersSet::Management::start_skel, 0},
      {"_get_autoMoveMode", &POA_RemoteServersSet::Management::_get_autoMoveMode_skel, 0},
      {"_set_autoMoveMode", &POA_RemoteServersSet::Management::_set_autoMoveMode_skel, 0},
      {"_get_currentCommStatus", &POA_RemoteServersSet::Management::_get_currentCommStatus_skel, 0},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -1,  -1,   5,  -1,  -1,  -1,  -1,   6, -10,  -2,   7, 
        8,   9, -13,  -2, -44,  -1,  12,  -1, -43,  -1,  -1,  -1,  -1,  -1, 
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  15, 
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname && !strncmp (str + 1, ptr->opname + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}

static TAO_RemoteServersSet_Management_Perfect_Hash_OpTable tao_RemoteServersSet_Management_optable;

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_ss.cpp:930

TAO::Collocation_Proxy_Broker *
RemoteServersSet__TAO_Management_Proxy_Broker_Factory_function ( ::CORBA::Object_ptr)
{
  return reinterpret_cast<TAO::Collocation_Proxy_Broker *> (0xdead); // Dummy
}

int
RemoteServersSet__TAO_Management_Proxy_Broker_Factory_Initializer (size_t)
{
  RemoteServersSet__TAO_Management_Proxy_Broker_Factory_function_pointer = 
    RemoteServersSet__TAO_Management_Proxy_Broker_Factory_function;
  
  return 0;
}

static int
RemoteServersSet__TAO_Management_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  RemoteServersSet__TAO_Management_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<size_t> (RemoteServersSet__TAO_Management_Proxy_Broker_Factory_Initializer)
    );

// TAO_IDL - Generated from 
// be/be_visitor_interface/interface_ss.cpp:103

POA_RemoteServersSet::Management::Management (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_RemoteServersSet_Management_optable;
}

POA_RemoteServersSet::Management::Management (const Management& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs)
{
}

POA_RemoteServersSet::Management::~Management (void)
{
}namespace POA_RemoteServersSet
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:127
  
  class _get_currentServer_Management
    : public TAO::Upcall_Command
  {
  public:
    inline _get_currentServer_Management (
      POA_RemoteServersSet::Management * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::CORBA::Char *>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Char *, TAO::SArg_Traits< ::CORBA::Char *>::ret_arg_type> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_->currentServer (
          ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK;
    }
  
  private:
    POA_RemoteServersSet::Management * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from 
// be/be_visitor_operation/operation_ss.cpp:190

void POA_RemoteServersSet::Management::_get_currentServer_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
    ACE_ENV_ARG_DECL
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::CORBA::Char *>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_RemoteServersSet::Management * const impl =
    static_cast<POA_RemoteServersSet::Management *> (servant);

  _get_currentServer_Management command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
}namespace POA_RemoteServersSet
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:127
  
  class _set_currentServer_Management
    : public TAO::Upcall_Command
  {
  public:
    inline _set_currentServer_Management (
      POA_RemoteServersSet::Management * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::CORBA::Char *>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Char *, TAO::SArg_Traits< ::CORBA::Char *>::in_arg_type> (
          this->operation_details_,
          this->args_,
          1);
        
      this->servant_->currentServer (
        arg_1
        ACE_ENV_ARG_PARAMETER);
      ACE_CHECK;
    }
  
  private:
    POA_RemoteServersSet::Management * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from 
// be/be_visitor_operation/operation_ss.cpp:190

void POA_RemoteServersSet::Management::_set_currentServer_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
    ACE_ENV_ARG_DECL
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Char *>::in_arg_val _tao_currentServer;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_currentServer
    };
  
  static size_t const nargs = 2;
  
  POA_RemoteServersSet::Management * const impl =
    static_cast<POA_RemoteServersSet::Management *> (servant);

  _set_currentServer_Management command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
}namespace POA_RemoteServersSet
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:127
  
  class _get_autoMoveMode_Management
    : public TAO::Upcall_Command
  {
  public:
    inline _get_autoMoveMode_Management (
      POA_RemoteServersSet::Management * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean, TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_->autoMoveMode (
          ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK;
    }
  
  private:
    POA_RemoteServersSet::Management * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from 
// be/be_visitor_operation/operation_ss.cpp:190

void POA_RemoteServersSet::Management::_get_autoMoveMode_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
    ACE_ENV_ARG_DECL
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_RemoteServersSet::Management * const impl =
    static_cast<POA_RemoteServersSet::Management *> (servant);

  _get_autoMoveMode_Management command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
}namespace POA_RemoteServersSet
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:127
  
  class _set_autoMoveMode_Management
    : public TAO::Upcall_Command
  {
  public:
    inline _set_autoMoveMode_Management (
      POA_RemoteServersSet::Management * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::ACE_InputCDR::to_boolean, TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::in_arg_type> (
          this->operation_details_,
          this->args_,
          1);
        
      this->servant_->autoMoveMode (
        arg_1
        ACE_ENV_ARG_PARAMETER);
      ACE_CHECK;
    }
  
  private:
    POA_RemoteServersSet::Management * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from 
// be/be_visitor_operation/operation_ss.cpp:190

void POA_RemoteServersSet::Management::_set_autoMoveMode_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
    ACE_ENV_ARG_DECL
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::in_arg_val _tao_autoMoveMode;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_autoMoveMode
    };
  
  static size_t const nargs = 2;
  
  POA_RemoteServersSet::Management * const impl =
    static_cast<POA_RemoteServersSet::Management *> (servant);

  _set_autoMoveMode_Management command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
}namespace POA_RemoteServersSet
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:127
  
  class _get_currentCommStatus_Management
    : public TAO::Upcall_Command
  {
  public:
    inline _get_currentCommStatus_Management (
      POA_RemoteServersSet::Management * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::CORBA::Long>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Long, TAO::SArg_Traits< ::CORBA::Long>::ret_arg_type> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_->currentCommStatus (
          ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK;
    }
  
  private:
    POA_RemoteServersSet::Management * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from 
// be/be_visitor_operation/operation_ss.cpp:190

void POA_RemoteServersSet::Management::_get_currentCommStatus_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
    ACE_ENV_ARG_DECL
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::CORBA::Long>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_RemoteServersSet::Management * const impl =
    static_cast<POA_RemoteServersSet::Management *> (servant);

  _get_currentCommStatus_Management command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
}namespace POA_RemoteServersSet
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:127
  
  class start_Management
    : public TAO::Upcall_Command
  {
  public:
    inline start_Management (
      POA_RemoteServersSet::Management * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::CORBA::Long>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Long, TAO::SArg_Traits< ::CORBA::Long>::ret_arg_type> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_->start (
          ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK;
    }
  
  private:
    POA_RemoteServersSet::Management * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from 
// be/be_visitor_operation/operation_ss.cpp:190

void POA_RemoteServersSet::Management::start_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
    ACE_ENV_ARG_DECL
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::CORBA::Long>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_RemoteServersSet::Management * const impl =
    static_cast<POA_RemoteServersSet::Management *> (servant);

  start_Management command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
}

// TAO_IDL - Generated from 
// be/be_visitor_interface/interface_ss.cpp:169

namespace POA_RemoteServersSet
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:127
  
  class _is_a_Management_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _is_a_Management_Upcall_Command (
      POA_RemoteServersSet::Management * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean, TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< ::CORBA::Char *>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Char *, TAO::SArg_Traits< ::CORBA::Char *>::in_arg_type> (
          this->operation_details_,
          this->args_,
          1);
        
      retval =
        this->servant_-> _is_a (
          arg_1
          ACE_ENV_ARG_PARAMETER);
      ACE_CHECK;
    }
  
  private:
    POA_RemoteServersSet::Management * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_RemoteServersSet::Management::_is_a_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
    ACE_ENV_ARG_DECL
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Char *>::in_arg_val _tao_repository_id;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };
  
  static size_t const nargs = 2;
  
  POA_RemoteServersSet::Management * const impl =
    static_cast<POA_RemoteServersSet::Management *> (servant);
  
  _is_a_Management_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
}namespace POA_RemoteServersSet
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:127
  
  class _non_existent_Management_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _non_existent_Management_Upcall_Command (
      POA_RemoteServersSet::Management * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean, TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _non_existent (
          ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK;
    }
  
  private:
    POA_RemoteServersSet::Management * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_RemoteServersSet::Management::_non_existent_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
    ACE_ENV_ARG_DECL
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_RemoteServersSet::Management * const impl =
    static_cast<POA_RemoteServersSet::Management *> (servant);
  
  _non_existent_Management_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
}namespace POA_RemoteServersSet
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:127
  
  class _repository_id_Management_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _repository_id_Management_Upcall_Command (
      POA_RemoteServersSet::Management * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::CORBA::Char *>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Char *, TAO::SArg_Traits< ::CORBA::Char *>::ret_arg_type> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _repository_id (
          ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK;
    }
  
  private:
    POA_RemoteServersSet::Management * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_RemoteServersSet::Management::_repository_id_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
    ACE_ENV_ARG_DECL
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::CORBA::Char *>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_RemoteServersSet::Management * const impl =
    static_cast<POA_RemoteServersSet::Management *> (servant);
  
  _repository_id_Management_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
}

// TAO_IDL - Generated from 
// be/be_visitor_interface/interface_ss.cpp:502

void POA_RemoteServersSet::Management::_interface_skel (
    TAO_ServerRequest & server_request, 
    void * /* servant_upcall */,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (_tao_adapter == 0)
    {
      ACE_THROW ( ::CORBA::INTF_REPOS ( ::CORBA::OMGVMCID | 1,
                                        ::CORBA::COMPLETED_NO));
    }
  
  POA_RemoteServersSet::Management * const impl =
    static_cast<POA_RemoteServersSet::Management *> (servant);
  ::CORBA::InterfaceDef_ptr _tao_retval = 
    impl->_get_interface (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK;
  
  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();
  
  ::CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (
        _tao_out,
        _tao_retval
      );
  
  _tao_adapter->dispose (_tao_retval);
  
  if (_tao_result == 0)
    {
      ACE_THROW ( ::CORBA::MARSHAL ());
    }
}namespace POA_RemoteServersSet
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:127
  
  class _get_component_Management_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _get_component_Management_Upcall_Command (
      POA_RemoteServersSet::Management * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Object, TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _get_component (
          ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK;
    }
  
  private:
    POA_RemoteServersSet::Management * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_RemoteServersSet::Management::_component_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
    ACE_ENV_ARG_DECL
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_RemoteServersSet::Management * const impl =
    static_cast<POA_RemoteServersSet::Management *> (servant);
  
  _get_component_Management_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
}

::CORBA::Boolean POA_RemoteServersSet::Management::_is_a (
    const char* value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  return
    (
      !ACE_OS::strcmp (
          value,
          "IDL:RemoteServersSet/Management:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_RemoteServersSet::Management::_interface_repository_id (void) const
{
  return "IDL:RemoteServersSet/Management:1.0";
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_ss.cpp:867

void POA_RemoteServersSet::Management::_dispatch (
    TAO_ServerRequest & req,
    void * servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this
                                     ACE_ENV_ARG_PARAMETER);
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_ss.cpp:815

RemoteServersSet::Management *
POA_RemoteServersSet::Management::_this (ACE_ENV_SINGLE_ARG_DECL)
{
  TAO_Stub *stub = this->_create_stub (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  ::CORBA::Boolean _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();
  
  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );
  
  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();
  
  typedef ::RemoteServersSet::Management STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        RemoteServersSet__TAO_Management_Proxy_Broker_Factory_function_pointer
      );
}

// TAO_IDL - Generated from
// be/be_interface.cpp:1511

class TAO_RemoteServersSet_EventListener_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_RemoteServersSet_EventListener_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_RemoteServersSet_EventListener_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16,  0,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16,  0,
     16, 16,  0,  5, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16,  0,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16,  0, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16,
#else
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16,  0, 16,  0, 16, 16,
      0,  5, 16, 16, 16, 16, 16, 16, 16, 16,
      0, 16, 16, 16, 16, 16,  0, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16,
#endif /* ACE_MVS */
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const TAO_operation_db_entry *
TAO_RemoteServersSet_EventListener_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 6,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 14,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 15,
      HASH_VALUE_RANGE = 11,
      DUPLICATES = 0,
      WORDLIST_SIZE = 11
    };

  static const TAO_operation_db_entry  wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"_is_a", &POA_RemoteServersSet::EventListener::_is_a_skel, 0},
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"_component", &POA_RemoteServersSet::EventListener::_component_skel, 0},
      {"notifyEvent", &POA_RemoteServersSet::EventListener::notifyEvent_skel, 0},
      {"",0,0},
      {"_non_existent", &POA_RemoteServersSet::EventListener::_non_existent_skel, 0},
      {"_repository_id", &POA_RemoteServersSet::EventListener::_repository_id_skel, 0},
      {"_interface", &POA_RemoteServersSet::EventListener::_interface_skel, 0},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          const char *s = wordlist[key].opname;

          if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
            return &wordlist[key];
        }
    }
  return 0;
}

static TAO_RemoteServersSet_EventListener_Perfect_Hash_OpTable tao_RemoteServersSet_EventListener_optable;

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_ss.cpp:930

TAO::Collocation_Proxy_Broker *
RemoteServersSet__TAO_EventListener_Proxy_Broker_Factory_function ( ::CORBA::Object_ptr)
{
  return reinterpret_cast<TAO::Collocation_Proxy_Broker *> (0xdead); // Dummy
}

int
RemoteServersSet__TAO_EventListener_Proxy_Broker_Factory_Initializer (size_t)
{
  RemoteServersSet__TAO_EventListener_Proxy_Broker_Factory_function_pointer = 
    RemoteServersSet__TAO_EventListener_Proxy_Broker_Factory_function;
  
  return 0;
}

static int
RemoteServersSet__TAO_EventListener_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  RemoteServersSet__TAO_EventListener_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<size_t> (RemoteServersSet__TAO_EventListener_Proxy_Broker_Factory_Initializer)
    );

// TAO_IDL - Generated from 
// be/be_visitor_interface/interface_ss.cpp:103

POA_RemoteServersSet::EventListener::EventListener (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_RemoteServersSet_EventListener_optable;
}

POA_RemoteServersSet::EventListener::EventListener (const EventListener& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs)
{
}

POA_RemoteServersSet::EventListener::~EventListener (void)
{
}namespace POA_RemoteServersSet
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:127
  
  class notifyEvent_EventListener
    : public TAO::Upcall_Command
  {
  public:
    inline notifyEvent_EventListener (
      POA_RemoteServersSet::EventListener * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::RemoteServersSet::Event>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::RemoteServersSet::Event, TAO::SArg_Traits< ::RemoteServersSet::Event>::in_arg_type> (
          this->operation_details_,
          this->args_,
          1);
        
      this->servant_->notifyEvent (
        arg_1
        ACE_ENV_ARG_PARAMETER);
      ACE_CHECK;
    }
  
  private:
    POA_RemoteServersSet::EventListener * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from 
// be/be_visitor_operation/operation_ss.cpp:190

void POA_RemoteServersSet::EventListener::notifyEvent_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
    ACE_ENV_ARG_DECL
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::RemoteServersSet::Event>::in_arg_val _tao_newEvent;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_newEvent
    };
  
  static size_t const nargs = 2;
  
  POA_RemoteServersSet::EventListener * const impl =
    static_cast<POA_RemoteServersSet::EventListener *> (servant);

  notifyEvent_EventListener command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
}

// TAO_IDL - Generated from 
// be/be_visitor_interface/interface_ss.cpp:169

namespace POA_RemoteServersSet
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:127
  
  class _is_a_EventListener_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _is_a_EventListener_Upcall_Command (
      POA_RemoteServersSet::EventListener * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean, TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< ::CORBA::Char *>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Char *, TAO::SArg_Traits< ::CORBA::Char *>::in_arg_type> (
          this->operation_details_,
          this->args_,
          1);
        
      retval =
        this->servant_-> _is_a (
          arg_1
          ACE_ENV_ARG_PARAMETER);
      ACE_CHECK;
    }
  
  private:
    POA_RemoteServersSet::EventListener * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_RemoteServersSet::EventListener::_is_a_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
    ACE_ENV_ARG_DECL
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Char *>::in_arg_val _tao_repository_id;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };
  
  static size_t const nargs = 2;
  
  POA_RemoteServersSet::EventListener * const impl =
    static_cast<POA_RemoteServersSet::EventListener *> (servant);
  
  _is_a_EventListener_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
}namespace POA_RemoteServersSet
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:127
  
  class _non_existent_EventListener_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _non_existent_EventListener_Upcall_Command (
      POA_RemoteServersSet::EventListener * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean, TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _non_existent (
          ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK;
    }
  
  private:
    POA_RemoteServersSet::EventListener * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_RemoteServersSet::EventListener::_non_existent_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
    ACE_ENV_ARG_DECL
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_RemoteServersSet::EventListener * const impl =
    static_cast<POA_RemoteServersSet::EventListener *> (servant);
  
  _non_existent_EventListener_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
}namespace POA_RemoteServersSet
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:127
  
  class _repository_id_EventListener_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _repository_id_EventListener_Upcall_Command (
      POA_RemoteServersSet::EventListener * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::CORBA::Char *>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Char *, TAO::SArg_Traits< ::CORBA::Char *>::ret_arg_type> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _repository_id (
          ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK;
    }
  
  private:
    POA_RemoteServersSet::EventListener * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_RemoteServersSet::EventListener::_repository_id_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
    ACE_ENV_ARG_DECL
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::CORBA::Char *>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_RemoteServersSet::EventListener * const impl =
    static_cast<POA_RemoteServersSet::EventListener *> (servant);
  
  _repository_id_EventListener_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
}

// TAO_IDL - Generated from 
// be/be_visitor_interface/interface_ss.cpp:502

void POA_RemoteServersSet::EventListener::_interface_skel (
    TAO_ServerRequest & server_request, 
    void * /* servant_upcall */,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (_tao_adapter == 0)
    {
      ACE_THROW ( ::CORBA::INTF_REPOS ( ::CORBA::OMGVMCID | 1,
                                        ::CORBA::COMPLETED_NO));
    }
  
  POA_RemoteServersSet::EventListener * const impl =
    static_cast<POA_RemoteServersSet::EventListener *> (servant);
  ::CORBA::InterfaceDef_ptr _tao_retval = 
    impl->_get_interface (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK;
  
  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();
  
  ::CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (
        _tao_out,
        _tao_retval
      );
  
  _tao_adapter->dispose (_tao_retval);
  
  if (_tao_result == 0)
    {
      ACE_THROW ( ::CORBA::MARSHAL ());
    }
}namespace POA_RemoteServersSet
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:127
  
  class _get_component_EventListener_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _get_component_EventListener_Upcall_Command (
      POA_RemoteServersSet::EventListener * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Object, TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _get_component (
          ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK;
    }
  
  private:
    POA_RemoteServersSet::EventListener * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_RemoteServersSet::EventListener::_component_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
    ACE_ENV_ARG_DECL
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_RemoteServersSet::EventListener * const impl =
    static_cast<POA_RemoteServersSet::EventListener *> (servant);
  
  _get_component_EventListener_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
}

::CORBA::Boolean POA_RemoteServersSet::EventListener::_is_a (
    const char* value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  return
    (
      !ACE_OS::strcmp (
          value,
          "IDL:RemoteServersSet/EventListener:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_RemoteServersSet::EventListener::_interface_repository_id (void) const
{
  return "IDL:RemoteServersSet/EventListener:1.0";
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_ss.cpp:867

void POA_RemoteServersSet::EventListener::_dispatch (
    TAO_ServerRequest & req,
    void * servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this
                                     ACE_ENV_ARG_PARAMETER);
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_ss.cpp:815

RemoteServersSet::EventListener *
POA_RemoteServersSet::EventListener::_this (ACE_ENV_SINGLE_ARG_DECL)
{
  TAO_Stub *stub = this->_create_stub (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  ::CORBA::Boolean _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();
  
  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );
  
  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();
  
  typedef ::RemoteServersSet::EventListener STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        RemoteServersSet__TAO_EventListener_Proxy_Broker_Factory_function_pointer
      );
}

// TAO_IDL - Generated from
// be/be_interface.cpp:1511

class TAO_RemoteServersSet_EventSubscriber_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_RemoteServersSet_EventSubscriber_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_RemoteServersSet_EventSubscriber_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19,  0,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19,  0,
     19, 19,  0,  0, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19,  0,  5,  0, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19,
#else
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19,  0, 19,  0, 19, 19,
      0,  0, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19,  0,  5,  0, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19,
#endif /* ACE_MVS */
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const TAO_operation_db_entry *
TAO_RemoteServersSet_EventSubscriber_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 7,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 14,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 18,
      HASH_VALUE_RANGE = 14,
      DUPLICATES = 0,
      WORDLIST_SIZE = 12
    };

  static const TAO_operation_db_entry  wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"_is_a", &POA_RemoteServersSet::EventSubscriber::_is_a_skel, 0},
      {"",0,0},{"",0,0},{"",0,0},
      {"subscribe", &POA_RemoteServersSet::EventSubscriber::subscribe_skel, 0},
      {"_interface", &POA_RemoteServersSet::EventSubscriber::_interface_skel, 0},
      {"unsubscribe", &POA_RemoteServersSet::EventSubscriber::unsubscribe_skel, 0},
      {"",0,0},{"",0,0},
      {"_repository_id", &POA_RemoteServersSet::EventSubscriber::_repository_id_skel, 0},
      {"_component", &POA_RemoteServersSet::EventSubscriber::_component_skel, 0},
      {"",0,0},{"",0,0},
      {"_non_existent", &POA_RemoteServersSet::EventSubscriber::_non_existent_skel, 0},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          const char *s = wordlist[key].opname;

          if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
            return &wordlist[key];
        }
    }
  return 0;
}

static TAO_RemoteServersSet_EventSubscriber_Perfect_Hash_OpTable tao_RemoteServersSet_EventSubscriber_optable;

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_ss.cpp:930

TAO::Collocation_Proxy_Broker *
RemoteServersSet__TAO_EventSubscriber_Proxy_Broker_Factory_function ( ::CORBA::Object_ptr)
{
  return reinterpret_cast<TAO::Collocation_Proxy_Broker *> (0xdead); // Dummy
}

int
RemoteServersSet__TAO_EventSubscriber_Proxy_Broker_Factory_Initializer (size_t)
{
  RemoteServersSet__TAO_EventSubscriber_Proxy_Broker_Factory_function_pointer = 
    RemoteServersSet__TAO_EventSubscriber_Proxy_Broker_Factory_function;
  
  return 0;
}

static int
RemoteServersSet__TAO_EventSubscriber_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  RemoteServersSet__TAO_EventSubscriber_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<size_t> (RemoteServersSet__TAO_EventSubscriber_Proxy_Broker_Factory_Initializer)
    );

// TAO_IDL - Generated from 
// be/be_visitor_interface/interface_ss.cpp:103

POA_RemoteServersSet::EventSubscriber::EventSubscriber (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_RemoteServersSet_EventSubscriber_optable;
}

POA_RemoteServersSet::EventSubscriber::EventSubscriber (const EventSubscriber& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs)
{
}

POA_RemoteServersSet::EventSubscriber::~EventSubscriber (void)
{
}namespace POA_RemoteServersSet
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:127
  
  class subscribe_EventSubscriber
    : public TAO::Upcall_Command
  {
  public:
    inline subscribe_EventSubscriber (
      POA_RemoteServersSet::EventSubscriber * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::CORBA::ULong>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::ULong, TAO::SArg_Traits< ::CORBA::ULong>::ret_arg_type> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< ::RemoteServersSet::EventListener>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::RemoteServersSet::EventListener, TAO::SArg_Traits< ::RemoteServersSet::EventListener>::in_arg_type> (
          this->operation_details_,
          this->args_,
          1);
        
      TAO::SArg_Traits< ::CORBA::ULong>::in_arg_type arg_2 =
        TAO::Portable_Server::get_in_arg< ::CORBA::ULong, TAO::SArg_Traits< ::CORBA::ULong>::in_arg_type> (
          this->operation_details_,
          this->args_,
          2);
        
      retval =
        this->servant_->subscribe (
          arg_1
          , arg_2
          ACE_ENV_ARG_PARAMETER);
      ACE_CHECK;
    }
  
  private:
    POA_RemoteServersSet::EventSubscriber * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from 
// be/be_visitor_operation/operation_ss.cpp:190

void POA_RemoteServersSet::EventSubscriber::subscribe_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
    ACE_ENV_ARG_DECL
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::CORBA::ULong>::ret_val retval;
  TAO::SArg_Traits< ::RemoteServersSet::EventListener>::in_arg_val _tao_clientsInterface;
  TAO::SArg_Traits< ::CORBA::ULong>::in_arg_val _tao_filter;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_clientsInterface,
      &_tao_filter
    };
  
  static size_t const nargs = 3;
  
  POA_RemoteServersSet::EventSubscriber * const impl =
    static_cast<POA_RemoteServersSet::EventSubscriber *> (servant);

  subscribe_EventSubscriber command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
}namespace POA_RemoteServersSet
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:127
  
  class unsubscribe_EventSubscriber
    : public TAO::Upcall_Command
  {
  public:
    inline unsubscribe_EventSubscriber (
      POA_RemoteServersSet::EventSubscriber * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::CORBA::ULong>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::ULong, TAO::SArg_Traits< ::CORBA::ULong>::ret_arg_type> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< ::RemoteServersSet::EventListener>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::RemoteServersSet::EventListener, TAO::SArg_Traits< ::RemoteServersSet::EventListener>::in_arg_type> (
          this->operation_details_,
          this->args_,
          1);
        
      retval =
        this->servant_->unsubscribe (
          arg_1
          ACE_ENV_ARG_PARAMETER);
      ACE_CHECK;
    }
  
  private:
    POA_RemoteServersSet::EventSubscriber * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from 
// be/be_visitor_operation/operation_ss.cpp:190

void POA_RemoteServersSet::EventSubscriber::unsubscribe_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
    ACE_ENV_ARG_DECL
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::CORBA::ULong>::ret_val retval;
  TAO::SArg_Traits< ::RemoteServersSet::EventListener>::in_arg_val _tao_clientsInterface;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_clientsInterface
    };
  
  static size_t const nargs = 2;
  
  POA_RemoteServersSet::EventSubscriber * const impl =
    static_cast<POA_RemoteServersSet::EventSubscriber *> (servant);

  unsubscribe_EventSubscriber command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
}

// TAO_IDL - Generated from 
// be/be_visitor_interface/interface_ss.cpp:169

namespace POA_RemoteServersSet
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:127
  
  class _is_a_EventSubscriber_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _is_a_EventSubscriber_Upcall_Command (
      POA_RemoteServersSet::EventSubscriber * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean, TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< ::CORBA::Char *>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Char *, TAO::SArg_Traits< ::CORBA::Char *>::in_arg_type> (
          this->operation_details_,
          this->args_,
          1);
        
      retval =
        this->servant_-> _is_a (
          arg_1
          ACE_ENV_ARG_PARAMETER);
      ACE_CHECK;
    }
  
  private:
    POA_RemoteServersSet::EventSubscriber * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_RemoteServersSet::EventSubscriber::_is_a_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
    ACE_ENV_ARG_DECL
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Char *>::in_arg_val _tao_repository_id;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };
  
  static size_t const nargs = 2;
  
  POA_RemoteServersSet::EventSubscriber * const impl =
    static_cast<POA_RemoteServersSet::EventSubscriber *> (servant);
  
  _is_a_EventSubscriber_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
}namespace POA_RemoteServersSet
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:127
  
  class _non_existent_EventSubscriber_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _non_existent_EventSubscriber_Upcall_Command (
      POA_RemoteServersSet::EventSubscriber * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean, TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _non_existent (
          ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK;
    }
  
  private:
    POA_RemoteServersSet::EventSubscriber * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_RemoteServersSet::EventSubscriber::_non_existent_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
    ACE_ENV_ARG_DECL
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_RemoteServersSet::EventSubscriber * const impl =
    static_cast<POA_RemoteServersSet::EventSubscriber *> (servant);
  
  _non_existent_EventSubscriber_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
}namespace POA_RemoteServersSet
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:127
  
  class _repository_id_EventSubscriber_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _repository_id_EventSubscriber_Upcall_Command (
      POA_RemoteServersSet::EventSubscriber * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::CORBA::Char *>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Char *, TAO::SArg_Traits< ::CORBA::Char *>::ret_arg_type> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _repository_id (
          ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK;
    }
  
  private:
    POA_RemoteServersSet::EventSubscriber * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_RemoteServersSet::EventSubscriber::_repository_id_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
    ACE_ENV_ARG_DECL
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::CORBA::Char *>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_RemoteServersSet::EventSubscriber * const impl =
    static_cast<POA_RemoteServersSet::EventSubscriber *> (servant);
  
  _repository_id_EventSubscriber_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
}

// TAO_IDL - Generated from 
// be/be_visitor_interface/interface_ss.cpp:502

void POA_RemoteServersSet::EventSubscriber::_interface_skel (
    TAO_ServerRequest & server_request, 
    void * /* servant_upcall */,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (_tao_adapter == 0)
    {
      ACE_THROW ( ::CORBA::INTF_REPOS ( ::CORBA::OMGVMCID | 1,
                                        ::CORBA::COMPLETED_NO));
    }
  
  POA_RemoteServersSet::EventSubscriber * const impl =
    static_cast<POA_RemoteServersSet::EventSubscriber *> (servant);
  ::CORBA::InterfaceDef_ptr _tao_retval = 
    impl->_get_interface (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK;
  
  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();
  
  ::CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (
        _tao_out,
        _tao_retval
      );
  
  _tao_adapter->dispose (_tao_retval);
  
  if (_tao_result == 0)
    {
      ACE_THROW ( ::CORBA::MARSHAL ());
    }
}namespace POA_RemoteServersSet
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:127
  
  class _get_component_EventSubscriber_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _get_component_EventSubscriber_Upcall_Command (
      POA_RemoteServersSet::EventSubscriber * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Object, TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _get_component (
          ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK;
    }
  
  private:
    POA_RemoteServersSet::EventSubscriber * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_RemoteServersSet::EventSubscriber::_component_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
    ACE_ENV_ARG_DECL
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_RemoteServersSet::EventSubscriber * const impl =
    static_cast<POA_RemoteServersSet::EventSubscriber *> (servant);
  
  _get_component_EventSubscriber_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
}

::CORBA::Boolean POA_RemoteServersSet::EventSubscriber::_is_a (
    const char* value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  return
    (
      !ACE_OS::strcmp (
          value,
          "IDL:RemoteServersSet/EventSubscriber:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_RemoteServersSet::EventSubscriber::_interface_repository_id (void) const
{
  return "IDL:RemoteServersSet/EventSubscriber:1.0";
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_ss.cpp:867

void POA_RemoteServersSet::EventSubscriber::_dispatch (
    TAO_ServerRequest & req,
    void * servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this
                                     ACE_ENV_ARG_PARAMETER);
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_ss.cpp:815

RemoteServersSet::EventSubscriber *
POA_RemoteServersSet::EventSubscriber::_this (ACE_ENV_SINGLE_ARG_DECL)
{
  TAO_Stub *stub = this->_create_stub (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  ::CORBA::Boolean _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();
  
  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );
  
  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();
  
  typedef ::RemoteServersSet::EventSubscriber STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        RemoteServersSet__TAO_EventSubscriber_Proxy_Broker_Factory_function_pointer
      );
}

#endif /* ifndef */

